<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rectangle Cut-and-Slide Tessellation Builder (Quadrant IV)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; align-items: flex-start; }
    .panel { border: 1px solid #ccc; border-radius: 12px; padding: 12px; }
    canvas { border: 1px solid #aaa; border-radius: 10px; background: #fff; display: block; }
    button { padding: 8px 10px; border-radius: 10px; border: 1px solid #bbb; background: #f7f7f7; cursor: pointer; }
    button:hover { background: #efefef; }
    label { display: inline-flex; gap: 8px; align-items: center; margin-right: 10px; flex-wrap: wrap; }
    input[type="number"] { width: 90px; }
    .small { color: #555; font-size: 13px; line-height: 1.35; }
    textarea { width: 100%; height: 200px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 13px; }
    .mode { font-weight: 600; }
    .pill { display:inline-block; padding: 2px 8px; border-radius: 999px; border:1px solid #ddd; background:#fafafa; font-size: 12px; margin-left: 8px;}
  </style>
</head>
<body>
  <h2>Rectangle Cut-and-Slide Tessellation Builder</h2>
  <p class="small">
    Start from a rectangle. Click to add points that “cut” the <b>top</b> edge and the <b>right</b> edge.
    Matching points are automatically translated to the <b>bottom</b> and <b>left</b> edges so the tile can tessellate by translation.
    Coordinates output are shown in <b>Quadrant IV</b> (positive x, negative y).
  </p>

  <div class="row">
    <div class="panel">
      <h3>Canvas</h3>
      <div class="small">
        Mode:
        <span class="mode" id="modeLabel">Top edge</span>
        <span class="pill" id="modeHint">click inside top band</span>
      </div>
      <canvas id="c" width="520" height="520"></canvas>

      <div style="margin-top:10px;">
        <label>Width
          <input id="w" type="number" min="50" max="450" step="10" value="100" />
        </label>
        <label>Height
          <input id="h" type="number" min="50" max="450" step="10" value="100" />
        </label>
        <label>Origin (x,y)
          <input id="ox" type="number" step="10" value="120" />
          <input id="oy" type="number" step="10" value="120" />
        </label>
        <button id="apply">Apply</button>
      </div>

      <div style="margin-top:10px;">
        <button id="modeTop">Edit Top/Bottom</button>
        <button id="modeRight">Edit Right/Left</button>
        <button id="undo">Undo</button>
        <button id="reset">Reset</button>
      </div>

      <p class="small" style="margin-top:10px;">
        <b>How to use:</b><br/>
        1) In <b>Top/Bottom</b> mode, click to add points to shape the top edge (a “notch” or “tab”).<br/>
        2) Switch to <b>Right/Left</b> mode and click to add points shaping the right edge.<br/>
        The bottom/left get the matching translated points automatically.<br/>
        <b>Translation vectors:</b> ⟨W,0⟩ and ⟨0,H⟩.
      </p>
    </div>

    <div class="panel" style="flex:1 1 420px;">
      <h3>Quadrant IV Point List</h3>
      <div class="small">
        Output uses the math-style plane with +x right and +y up, but we report points in the <b>4th quadrant</b>:
        <b>(x, -y)</b> relative to the rectangle’s origin.
      </div>
      <textarea id="out" readonly></textarea>
      <div style="margin-top:10px;">
        <button id="copy">Copy polygon()</button>
      </div>
      <p class="small">
        Tip: If your drawing canvas uses y increasing downward, these points are already in the convenient “4th quadrant” form.
      </p>
        <p>Try the <a href="hexagon.html">hexagon</a> option - this makes your project harder to code.</p
    </div>
      
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const modeLabel = document.getElementById('modeLabel');
  const modeHint = document.getElementById('modeHint');
  const out = document.getElementById('out');

  // Origin in canvas pixels
  let ox = 120, oy = 120;

  // Rectangle dimensions (local coords)
  let W = 100, H = 100;

  // Allow editing slightly outside the rectangle
  const PAD = 50;

  // Cut points (local coords, y down)
  let topCuts = [];
  let rightCuts = [];

  let history = [];
  let mode = "top"; // "top" or "right"

  function pushHistory() {
    history.push({
      topCuts: topCuts.map(p => ({...p})),
      rightCuts: rightCuts.map(p => ({...p})),
      mode,
      W, H, ox, oy
    });
    if (history.length > 50) history.shift();
  }

  function undo() {
    const prev = history.pop();
    if (!prev) return;
    topCuts = prev.topCuts;
    rightCuts = prev.rightCuts;
    mode = prev.mode;
    W = prev.W; H = prev.H; ox = prev.ox; oy = prev.oy;
    // update inputs to match undo state
    document.getElementById('w').value = W;
    document.getElementById('h').value = H;
    document.getElementById('ox').value = ox;
    document.getElementById('oy').value = oy;
    updateModeUI();
    redraw();
  }

  function reset() {
    topCuts = [];
    rightCuts = [];
    history = [];
    redraw();
  }

  function setMode(m) {
    mode = m;
    updateModeUI();
    redraw();
  }

  function updateModeUI() {
    if (mode === "top") {
      modeLabel.textContent = "Top edge";
      modeHint.textContent = `click top band (incl. ${PAD}px above)`;
    } else {
      modeLabel.textContent = "Right edge";
      modeHint.textContent = `click right band (incl. ${PAD}px outside)`;
    }
  }

  // Accept clicks near the relevant edge (extended by PAD)
  function inActiveBand(p) {
    if (mode === "top") {
      // x in [0, W], y in [-PAD, 0.45H]
      return (p.x >= 0 && p.x <= W && p.y >= -PAD && p.y <= H * 0.45);
    } else {
      // y in [0, H], x in [0.55W, W+PAD]
      return (p.y >= 0 && p.y <= H && p.x >= W * 0.55 && p.x <= W + PAD);
    }
  }

  function clampPoint(p) {
    return {
      x: Math.max(-PAD, Math.min(W + PAD, p.x)),
      y: Math.max(-PAD, Math.min(H + PAD, p.y)),
    };
  }

  function sortTopCuts() { topCuts.sort((a,b)=>a.x-b.x); }
  function sortRightCuts() { rightCuts.sort((a,b)=>a.y-b.y); }

  // Rectangle corners (local)
  const TL = () => ({x:0, y:0});
  const TR = () => ({x:W, y:0});
  const BR = () => ({x:W, y:H});
  const BL = () => ({x:0, y:H});

  function boundaryLocalPoints() {
    sortTopCuts();
    sortRightCuts();

    const pts = [];

    // Top: TL -> cuts -> TR
    pts.push(TL());
    for (const p of topCuts) pts.push({x: p.x, y: p.y});
    pts.push(TR());

    // Right: cuts -> BR
    for (const p of rightCuts) pts.push({x: p.x, y: p.y});
    pts.push(BR());

    // Bottom: translate topCuts by (0, +H) and reverse, travel BR -> BL
    for (let i = topCuts.length - 1; i >= 0; i--) {
      const p = topCuts[i];
      pts.push({x: p.x, y: p.y + H});
    }
    pts.push(BL());

    // Left: translate rightCuts by (-W, 0) and reverse, travel BL -> TL
    for (let i = rightCuts.length - 1; i >= 0; i--) {
      const p = rightCuts[i];
      pts.push({x: p.x - W, y: p.y});
    }

    return pts;
  }

  function drawGrid() {
    ctx.save();
    ctx.clearRect(0,0,canvas.width,canvas.height);

    ctx.strokeStyle = "#eee";
    ctx.lineWidth = 1;
    for (let x=0; x<=canvas.width; x+=20) {
      ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,canvas.height); ctx.stroke();
    }
    for (let y=0; y<=canvas.height; y+=20) {
      ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(canvas.width,y+0.5); ctx.stroke();
    }
    ctx.restore();
  }

  function drawRect() {
    ctx.save();
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 2;
    ctx.strokeRect(ox+0.5, oy+0.5, W, H);

    // band hints (including PAD outside)
    ctx.fillStyle = "rgba(80,120,255,0.08)";
    // Top band: from y=-PAD to y=0.45H
    ctx.fillRect(ox, oy - PAD, W, H * 0.45 + PAD);
    // Right band: from x=0.55W to x=W+PAD
    ctx.fillRect(ox + W * 0.55, oy, W * 0.45 + PAD, H);

    ctx.fillStyle = "#333";
    ctx.font = "12px system-ui";
    ctx.fillText("Rectangle start", ox+6, oy-8);
    ctx.restore();
  }

  function drawPolygon() {
    const pts = boundaryLocalPoints().map(p => ({x: ox+p.x, y: oy+p.y}));

    ctx.save();
    ctx.fillStyle = "rgba(200, 60, 60, 0.18)";
    ctx.strokeStyle = "rgba(200, 60, 60, 0.9)";
    ctx.lineWidth = 2;

    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    ctx.save();
    ctx.fillStyle = "#c00";
    for (const p of pts) {
      ctx.beginPath();
      ctx.arc(p.x, p.y, 3.2, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function round1(n) {
    const r = Math.round(n * 10) / 10;
    return Number.isInteger(r) ? r.toString() : r.toString();
  }

  function updateOutput() {
    const pts = boundaryLocalPoints();
    // Quadrant IV output: (x, -y)
    const q4 = pts.map(p => `(${round1(p.x)}, ${round1(-p.y)})`);
    const poly = "polygon(\n  " + q4.join(",\n  ") + "\n)";
    out.value = poly;
  }

  function redraw() {
    drawGrid();
    drawRect();
    drawPolygon();
    updateOutput();
  }

  function canvasToLocal(evt) {
    const rect = canvas.getBoundingClientRect();
    const cx = evt.clientX - rect.left;
    const cy = evt.clientY - rect.top;
    return { x: cx - ox, y: cy - oy };
  }

  function addPoint(local) {
    const p = clampPoint(local);
    if (!inActiveBand(p)) return;

    pushHistory();

    if (mode === "top") topCuts.push(p);
    else rightCuts.push(p);

    redraw();
  }

  canvas.addEventListener('click', (evt) => {
    const local = canvasToLocal(evt);
    const p = clampPoint(local);
    if (!inActiveBand(p)) return;
    addPoint(p);
  });

  // Controls
  document.getElementById('modeTop').addEventListener('click', () => setMode("top"));
  document.getElementById('modeRight').addEventListener('click', () => setMode("right"));
  document.getElementById('undo').addEventListener('click', undo);
  document.getElementById('reset').addEventListener('click', reset);

  document.getElementById('apply').addEventListener('click', () => {
    pushHistory();

    const nw = Number(document.getElementById('w').value);
    const nh = Number(document.getElementById('h').value);
    const nox = Number(document.getElementById('ox').value);
    const noy = Number(document.getElementById('oy').value);

    W = Math.max(50, Math.min(450, nw));
    H = Math.max(50, Math.min(450, nh));
    ox = nox; oy = noy;

    // Clamp existing points to new rectangle bounds (+PAD)
    topCuts = topCuts.map(clampPoint);
    rightCuts = rightCuts.map(clampPoint);

    redraw();
  });

  document.getElementById('copy').addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(out.value);
      alert("Copied polygon() to clipboard!");
    } catch {
      alert("Could not copy automatically. Select and copy from the box.");
    }
  });

  updateModeUI();
  redraw();
})();
</script>
</body>
</html>
